# Assignment 08: ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ Recursive Algorithms ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Game Development

## üéØ ‡∏à‡∏∏‡∏î‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ

- ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Recursive Algorithms ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (Factorial, Fibonacci, Power, GCD, Binary Search)
- ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á Recursion ‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á Base Case ‡πÅ‡∏•‡∏∞ Recursive Case
- ‡∏ô‡∏≥ Recursive Algorithms ‡∏°‡∏≤‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÉ‡∏ô‡πÄ‡∏Å‡∏° ‡πÄ‡∏ä‡πà‡∏ô ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏≠‡∏°‡∏ö‡∏¥‡πÄ‡∏ô‡∏ä‡∏±‡∏ô, ‡∏•‡∏≥‡∏î‡∏±‡∏ö Fibonacci ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö AI, ‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Palindrome
- ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏≠‡∏á Recursion
- ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô code ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏ó‡∏µ‡πà‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏î‡πâ‡∏ß‡∏¢ Recursion

## üìö ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á Assignment

- **Lecture Methods (4 methods)** - ‡∏Å‡∏≤‡∏£ implement ‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î Recursive Algorithms ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô
- **Assignment Methods (4 methods)** - ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ Recursive Algorithms ‡πÉ‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ì‡πå‡πÄ‡∏Å‡∏°

---

## üß† ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏π‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡∏ó‡∏£‡∏≤‡∏ö

### Recursion ‡∏Ñ‡∏∑‡∏≠‡∏≠‡∏∞‡πÑ‡∏£?
Recursion ‡∏Ñ‡∏∑‡∏≠‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏ã‡πâ‡∏≥‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤ ‡πÇ‡∏î‡∏¢‡πÅ‡∏ö‡πà‡∏á‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÉ‡∏´‡∏ç‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏¢‡πà‡∏≠‡∏¢‡πÜ ‡∏à‡∏ô‡∏ñ‡∏∂‡∏á Base Case ‡∏ó‡∏µ‡πà‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ã‡πâ‡∏≥

### ‡∏™‡πà‡∏ß‡∏ô‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö‡∏Ç‡∏≠‡∏á Recursion
- **Base Case**: ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ã‡πâ‡∏≥
- **Recursive Case**: ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏î‡πâ‡∏ß‡∏¢ input ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πá‡∏Å‡∏•‡∏á

### ‡πÉ‡∏ä‡πâ Recursion ‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£‡∏ö‡πâ‡∏≤‡∏á?
- **‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏≠‡∏°‡∏ö‡∏¥‡πÄ‡∏ô‡∏ä‡∏±‡∏ô**: Factorial ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á
- **‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö**: Fibonacci ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏¥‡∏ö‡πÇ‡∏ï
- **‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤**: Binary Search ‡πÉ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö
- **‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö**: Palindrome ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏≥‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏´‡∏±‡∏™

---

## Lecture Methods

### 1. LCT01_RecursiveFactorial

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Factorial ‡∏î‡πâ‡∏ß‡∏¢ Recursion

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏õ‡∏±‡∏ç‡∏´‡∏≤:**
Factorial (n!) ‡∏Ñ‡∏∑‡∏≠‡∏ú‡∏•‡∏Ñ‡∏π‡∏ì‡∏Ç‡∏≠‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ö‡∏ß‡∏Å‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà 1 ‡∏ñ‡∏∂‡∏á n ‡πÄ‡∏ä‡πà‡∏ô 5! = 5 √ó 4 √ó 3 √ó 2 √ó 1 = 120

‡πÉ‡∏ô‡πÄ‡∏Å‡∏° Factorial ‡∏°‡∏±‡∏Å‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì:
- ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏° (Permutation)
- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏≠‡∏°‡∏ö‡∏¥‡πÄ‡∏ô‡∏ä‡∏±‡∏ô‡∏ï‡πà‡∏≤‡∏á‡πÜ
- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏∞‡∏ö‡∏ö progression ‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡πÅ‡∏ö‡∏ö‡∏ó‡∏ß‡∏µ‡∏Ñ‡∏π‡∏ì

**‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á Factorial:**
- n! = n * (n-1) * (n-2) * ... * 1
- Base Case: 
    + 0! ‡∏´‡∏£‡∏∑‡∏≠ factorial(0) = 1 
    + 1! ‡∏´‡∏£‡∏∑‡∏≠ factorial(1) = 1
- Recursive Case: n! = n * (n-1)!

**Method Signature:**
```csharp
void LCT01_RecursiveFactorial(int n)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
1. ‡∏™‡∏£‡πâ‡∏≤‡∏á helper method ‡πÅ‡∏ö‡∏ö recursive ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö parameter n
2. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Base Case: ‡∏ñ‡πâ‡∏≤ n <= 1 ‡πÉ‡∏´‡πâ return 1
3. Recursive Case: return n * Factorial(n-1)
4. ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç

**Test Cases:**
1. **Input:** n = 5
   **Expected Output:**
   ```
   120
   ```

2. **Input:** n = 0
   **Expected Output:**
   ```
   1
   ```

3. **Input:** n = 1
   **Expected Output:**
   ```
   1
   ```

4. **Input:** n = 3
   **Expected Output:**
   ```
   6
   ```

5. **Input:** n = 4
   **Expected Output:**
   ```
   24
   ```

6. **Input:** n = 6
   **Expected Output:**
   ```
   720
   ```

### 2. LCT02_RecursiveFibonacci

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Fibonacci Sequence ‡∏î‡πâ‡∏ß‡∏¢ Recursion

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏õ‡∏±‡∏ç‡∏´‡∏≤:**
Fibonacci Sequence ‡πÄ‡∏õ‡πá‡∏ô‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡πÄ‡∏õ‡πá‡∏ô‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á‡∏™‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤ ‡πÄ‡∏ä‡πà‡∏ô 0, 1, 1, 2, 3, 5, 8, 13, 21...

‡πÉ‡∏ô‡πÄ‡∏Å‡∏° Fibonacci ‡∏°‡∏±‡∏Å‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£:
- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡∏Ç‡∏≠‡∏á AI ‡∏ó‡∏µ‡πà‡∏î‡∏π‡πÄ‡∏õ‡πá‡∏ô‡∏ò‡∏£‡∏£‡∏°‡∏ä‡∏≤‡∏ï‡∏¥
- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏®‡∏±‡∏ï‡∏£‡∏π‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡∏ï‡∏≤‡∏° level
- ‡∏™‡∏£‡πâ‡∏≤‡∏á pattern ‡πÉ‡∏ô‡πÄ‡∏Å‡∏° puzzle ‡∏´‡∏£‡∏∑‡∏≠ rhythm game
- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÅ‡∏ö‡∏ö progressive

**‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á Fibonacci:**
- F(0) = 0, F(1) = 1
- F(n) = F(n-1) + F(n-2) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö n > 1

**Method Signature:**
```csharp
void LCT02_RecursiveFibonacci(int n)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
1. ‡∏™‡∏£‡πâ‡∏≤‡∏á helper method ‡πÅ‡∏ö‡∏ö recursive ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö parameter n
2. Base Case: ‡∏ñ‡πâ‡∏≤ n <= 1 ‡πÉ‡∏´‡πâ return n
3. Recursive Case: return Fibonacci(n-1) + Fibonacci(n-2)
4. ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç

**‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:** ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Recursion ‡πÅ‡∏ö‡∏ö‡∏ò‡∏£‡∏£‡∏°‡∏î‡∏≤‡∏Å‡∏±‡∏ö Fibonacci ‡∏à‡∏∞‡∏ä‡πâ‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö n ‡πÉ‡∏´‡∏ç‡πà ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ã‡πâ‡∏≥ (Time Complexity: O(2^n))

**Test Cases:**
1. **Input:** n = 6
   **Expected Output:**
   ```
   8
   ```

2. **Input:** n = 0
   **Expected Output:**
   ```
   0
   ```

3. **Input:** n = 1
   **Expected Output:**
   ```
   1
   ```

4. **Input:** n = 2
   **Expected Output:**
   ```
   1
   ```

5. **Input:** n = 3
   **Expected Output:**
   ```
   2
   ```

6. **Input:** n = 4
   **Expected Output:**
   ```
   3
   ```

7. **Input:** n = 5
   **Expected Output:**
   ```
   5
   ```

### 3. LCT03_RecursiveSumOfOneToN

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏à‡∏≤‡∏Å 1 ‡∏ñ‡∏∂‡∏á N ‡∏î‡πâ‡∏ß‡∏¢ Recursion

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏õ‡∏±‡∏ç‡∏´‡∏≤:**
‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ö‡∏ß‡∏Å‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà 1 ‡∏ñ‡∏∂‡∏á n ‡πÄ‡∏ä‡πà‡∏ô Sum(5) = 1 + 2 + 3 + 4 + 5 = 15

‡πÉ‡∏ô‡πÄ‡∏Å‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£:
- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì experience points ‡∏™‡∏∞‡∏™‡∏°
- ‡∏´‡∏≤‡∏ú‡∏•‡∏£‡∏ß‡∏° damage ‡∏´‡∏£‡∏∑‡∏≠ score ‡∏à‡∏≤‡∏Å‡∏´‡∏•‡∏≤‡∏¢‡πÅ‡∏´‡∏•‡πà‡∏á
- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≥‡∏ô‡∏ß‡∏ô resource ‡∏ó‡∏µ‡πà‡∏™‡∏∞‡∏™‡∏°‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ level
- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÅ‡∏ö‡∏ö accumulative

**‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô:**
- Sum(0) = 0 (Base Case)
- Sum(n) = n + Sum(n-1) (Recursive Case)

**Method Signature:**
```csharp
void LCT03_RecursiveSumOfOneToN(int n)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
1. ‡∏™‡∏£‡πâ‡∏≤‡∏á helper method ‡πÅ‡∏ö‡∏ö recursive ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö parameter n
2. Base Case: ‡∏ñ‡πâ‡∏≤ n <= 0 ‡πÉ‡∏´‡πâ return 0
3. Recursive Case: return n + SumOfOneToN(n-1)
4. ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß

**Test Cases:**
1. **Input:** n = 5
   **Expected Output:**
   ```
   15
   ```

2. **Input:** n = 0
   **Expected Output:**
   ```
   0
   ```

3. **Input:** n = 1
   **Expected Output:**
   ```
   1
   ```

4. **Input:** n = 3
   **Expected Output:**
   ```
   6
   ```

5. **Input:** n = 10
   **Expected Output:**
   ```
   55
   ```

6. **Input:** n = 2
   **Expected Output:**
   ```
   3
   ```

### 4. LCT04_RecursiveSumOfNumbers

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á Array ‡∏î‡πâ‡∏ß‡∏¢ Recursion

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏õ‡∏±‡∏ç‡∏´‡∏≤:**
‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô array ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ Recursion ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ loop 

‡πÉ‡∏ô‡πÄ‡∏Å‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£:
- ‡∏£‡∏ß‡∏° score ‡∏´‡∏£‡∏∑‡∏≠ points ‡∏à‡∏≤‡∏Å array ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏ô
- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì total damage ‡∏à‡∏≤‡∏Å array ‡∏Ç‡∏≠‡∏á‡∏≠‡∏≤‡∏ß‡∏∏‡∏ò‡∏´‡∏£‡∏∑‡∏≠ skills
- ‡∏´‡∏≤ total value ‡∏Ç‡∏≠‡∏á‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô inventory
- ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö recursive ‡πÅ‡∏ó‡∏ô iterative

**‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô:**
- ‡πÉ‡∏ä‡πâ index ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏î‡∏¥‡∏ô‡∏ú‡πà‡∏≤‡∏ô Array
- Base Case: ‡πÄ‡∏°‡∏∑‡πà‡∏≠ index >= length, return 0
- Recursive Case: array[index] + Sum(array, index+1)

**Method Signature:**
```csharp
void LCT04_RecursiveSumOfNumbers(int[] numbers)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
1. ‡∏™‡∏£‡πâ‡∏≤‡∏á helper method ‡πÅ‡∏ö‡∏ö recursive ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö parameters: array ‡πÅ‡∏•‡∏∞ index
2. Base Case: ‡∏ñ‡πâ‡∏≤ index >= array.Length ‡πÉ‡∏´‡πâ return 0
3. Recursive Case: return array[index] + SumOfNumbers(array, index+1)
4. ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ helper method ‡πÇ‡∏î‡∏¢‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏µ‡πà index = 0
5. ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç

**‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:** Array ‡∏ß‡πà‡∏≤‡∏á‡∏à‡∏∞‡πÉ‡∏´‡πâ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏õ‡πá‡∏ô 0

**Test Cases:**
1. **Input:** numbers = [1, 2, 3, 4, 5]
   **Expected Output:**
   ```
   15
   ```

2. **Input:** numbers = []
   **Expected Output:**
   ```
   0
   ```

3. **Input:** numbers = [10]
   **Expected Output:**
   ```
   10
   ```

4. **Input:** numbers = [1, 2, 3]
   **Expected Output:**
   ```
   6
   ```

5. **Input:** numbers = [0, 0, 0]
   **Expected Output:**
   ```
   0
   ```

6. **Input:** numbers = [-1, 1]
   **Expected Output:**
   ```
   0
   ```

---

## Assignment Methods

### ASN01_RecursivePower

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏•‡∏Ç‡∏¢‡∏Å‡∏Å‡∏≥‡∏•‡∏±‡∏á (Power) ‡∏î‡πâ‡∏ß‡∏¢ Recursion

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏õ‡∏±‡∏ç‡∏´‡∏≤:**
‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤ base^exponent ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ Recursion ‡πÄ‡∏ä‡πà‡∏ô 2^3 = 2 √ó 2 √ó 2 = 8

‡πÉ‡∏ô‡πÄ‡∏Å‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£:
- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì damage ‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡πÅ‡∏ö‡∏ö exponential ‡∏ï‡∏≤‡∏° level ‡∏´‡∏£‡∏∑‡∏≠ combo
- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏∞‡∏ö‡∏ö multiplier ‡∏ó‡∏µ‡πà‡∏ó‡∏ß‡∏µ‡∏Ñ‡∏π‡∏ì (‡πÄ‡∏ä‡πà‡∏ô critical hit)
- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì growth rate ‡∏Ç‡∏≠‡∏á stats ‡∏ï‡πà‡∏≤‡∏á‡πÜ
- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏∞‡∏ö‡∏ö progression ‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏£‡∏ß‡∏î‡πÄ‡∏£‡πá‡∏ß

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÉ‡∏ô‡πÄ‡∏Å‡∏°:** 
- Damage = BaseDamage √ó Power(ComboMultiplier, ComboCount)
- ExpRequired = BaseExp √ó Power(LevelMultiplier, CurrentLevel)

**Method Signature:**
```csharp
void ASN01_RecursivePower(int baseNum, int exponent)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
1. ‡∏™‡∏£‡πâ‡∏≤‡∏á helper method ‡πÅ‡∏ö‡∏ö recursive ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö parameters: baseNum ‡πÅ‡∏•‡∏∞ exponent
2. Base Case: ‡∏ñ‡πâ‡∏≤ exponent == 0 ‡πÉ‡∏´‡πâ return 1 (‡πÄ‡∏û‡∏£‡∏≤‡∏∞ x^0 = 1)
3. Recursive Case: return baseNum * Power(baseNum, exponent-1)
4. ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç

**‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:** ‡πÇ‡∏à‡∏ó‡∏¢‡πå‡∏ô‡∏µ‡πâ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤ exponent ‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ö‡∏ß‡∏Å‡∏´‡∏£‡∏∑‡∏≠ 0

**Test Cases:**
1. **Input:** baseNum = 2, exponent = 3
   **Expected Output:**
   ```
   8
   ```

2. **Input:** baseNum = 5, exponent = 0
   **Expected Output:**
   ```
   1
   ```

3. **Input:** baseNum = 3, exponent = 2
   **Expected Output:**
   ```
   9
   ```

4. **Input:** baseNum = 4, exponent = 2
   **Expected Output:**
   ```
   16
   ```

5. **Input:** baseNum = 1, exponent = 5
   **Expected Output:**
   ```
   1
   ```

6. **Input:** baseNum = 10, exponent = 1
   **Expected Output:**
   ```
   10
   ```

### ASN02_IsPalindrome

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ String ‡πÄ‡∏õ‡πá‡∏ô Palindrome ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏î‡πâ‡∏ß‡∏¢ Recursion

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏õ‡∏±‡∏ç‡∏´‡∏≤:**
Palindrome ‡∏Ñ‡∏∑‡∏≠‡∏Ñ‡∏≥‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏≠‡πà‡∏≤‡∏ô‡∏à‡∏≤‡∏Å‡∏ã‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏Ç‡∏ß‡∏≤‡πÅ‡∏•‡∏∞‡∏Ç‡∏ß‡∏≤‡πÑ‡∏õ‡∏ã‡πâ‡∏≤‡∏¢‡πÑ‡∏î‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô ‡πÄ‡∏ä‡πà‡∏ô "radar", "aba", "noon"

‡πÉ‡∏ô‡πÄ‡∏Å‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£:
- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏¥‡∏®‡∏ô‡∏≤‡∏´‡∏£‡∏∑‡∏≠ puzzle ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏≤‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô palindrome
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏´‡∏£‡∏∑‡∏≠ code ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏û‡∏¥‡πÄ‡∏®‡∏©
- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö pattern ‡πÉ‡∏ô‡πÄ‡∏Å‡∏° word game
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á input ‡πÉ‡∏ô‡πÄ‡∏Å‡∏° puzzle

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÉ‡∏ô‡πÄ‡∏Å‡∏°:** 
- Puzzle game ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô palindrome
- RPG ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ magic word ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô palindrome ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ
- Word game ‡∏ó‡∏µ‡πà‡πÉ‡∏´‡πâ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏û‡∏¥‡πÄ‡∏®‡∏©‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô palindrome

**Method Signature:**
```csharp
void ASN02_IsPalindrome(string str)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
1. ‡∏™‡∏£‡πâ‡∏≤‡∏á helper method ‡πÅ‡∏ö‡∏ö recursive ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö parameters: string, start index, end index
2. Base Case: ‡∏ñ‡πâ‡∏≤ start >= end ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß return true
3. ‡∏ñ‡πâ‡∏≤ str[start] != str[end] ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà palindrome return false
4. Recursive Case: return IsPalindrome(str, start+1, end-1)
5. ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° "is a palindrome" ‡∏´‡∏£‡∏∑‡∏≠ "is not a palindrome"

**‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:** String ‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏•‡∏∞ string ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô palindrome

**Test Cases:**
1. **Input:** str = "radar"
   **Expected Output:**
   ```
   is a palindrome
   ```

2. **Input:** str = "hello"
   **Expected Output:**
   ```
   is not a palindrome
   ```

3. **Input:** str = "a"
   **Expected Output:**
   ```
   is a palindrome
   ```

4. **Input:** str = ""
   **Expected Output:**
   ```
   is a palindrome
   ```

5. **Input:** str = "aba"
   **Expected Output:**
   ```
   is a palindrome
   ```

6. **Input:** str = "abcba"
   **Expected Output:**
   ```
   is a palindrome
   ```

7. **Input:** str = "ab"
   **Expected Output:**
   ```
   is not a palindrome
   ```

8. **Input:** str = "aa"
   **Expected Output:**
   ```
   is a palindrome
   ```

### ASN03_RecursiveGCD

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Greatest Common Divisor (GCD) ‡∏î‡πâ‡∏ß‡∏¢ Recursion ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ Euclidean Algorithm

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏õ‡∏±‡∏ç‡∏´‡∏≤:**
GCD (Greatest Common Divisor) ‡∏´‡∏£‡∏∑‡∏≠ ‡∏´.‡∏£.‡∏°. (‡∏´‡∏≤‡∏£‡∏£‡πà‡∏ß‡∏°‡∏°‡∏≤‡∏Å) ‡∏Ñ‡∏∑‡∏≠‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏ö‡∏ß‡∏Å‡∏ó‡∏µ‡πà‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏´‡∏≤‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏•‡∏á‡∏ï‡∏±‡∏ß ‡πÄ‡∏ä‡πà‡∏ô GCD(48, 18) = 6

Euclidean Algorithm ‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏´‡∏≤ GCD ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£:
- GCD(a, b) = GCD(b, a mod b)
- ‡∏ó‡∏≥‡∏ã‡πâ‡∏≥‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤ b = 0 ‡πÅ‡∏•‡πâ‡∏ß GCD ‡∏Ñ‡∏∑‡∏≠ a

### ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô GCD ‡πÉ‡∏ô Game Development:

#### 1. **Screen Resolution & Aspect Ratio**
‡πÉ‡∏ä‡πâ GCD ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î‡∏ó‡∏≠‡∏ô resolution ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô aspect ratio ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢
```
Example: Resolution 1920x1080
GCD(1920, 1080) = 120
Aspect Ratio = 1920/120 : 1080/120 = 16:9
```
- ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö UI ‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î
- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì viewport scaling ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
- ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ letterboxing/pillarboxing

#### 2. **Animation & Frame Rate Synchronization**
‡∏ã‡∏¥‡∏á‡∏Ñ‡πå animation cycles ‡∏ó‡∏µ‡πà‡∏°‡∏µ frame rate ‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô
```
Example: 
- Animation A: 30 frames/cycle
- Animation B: 20 frames/cycle
GCD(30, 20) = 10
‡∏à‡∏∞‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏Å‡∏±‡∏ô‡∏ó‡∏∏‡∏Å‡πÜ 10 frames
```
- ‡∏õ‡∏£‡∏∞‡∏™‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡πÅ‡∏•‡∏∞ background
- ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå particle effects ‡∏Å‡∏±‡∏ö main animation
- ‡∏´‡∏≤‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞‡∏ó‡∏µ‡πà multiple animations ‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô‡∏û‡∏≠‡∏î‡∏µ

#### 3. **Grid System & Tile-based Games**
‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ grid size ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ
```
Example: 
- Character size: 48 pixels
- Tile size: 32 pixels
GCD(48, 32) = 16
Base unit = 16 pixels (‡∏ó‡∏±‡πâ‡∏á character ‡πÅ‡∏•‡∏∞ tile ‡∏´‡∏≤‡∏£‡∏î‡πâ‡∏ß‡∏¢ 16 ‡∏•‡∏á‡∏ï‡∏±‡∏ß)
```
- ‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö tilemap ‡∏ó‡∏µ‡πà object ‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡πà‡∏≤‡∏á‡πÜ fit ‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ
- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì collision detection ‡∏ó‡∏µ‡πà‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥
- ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ snap-to-grid functionality

#### 4. **Resource Management & Crafting System**
‡∏•‡∏î‡∏ó‡∏≠‡∏ô‡∏™‡∏π‡∏ï‡∏£ crafting ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢
```
Example: 
Recipe: 24 Wood + 18 Stone = 1 Item
GCD(24, 18) = 6
Simplified: 4 Wood + 3 Stone = 1 Item
```
- ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏π‡∏ï‡∏£ crafting ‡∏ó‡∏µ‡πà‡∏≠‡πà‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢
- ‡∏•‡∏î‡∏ó‡∏≠‡∏ô resource ratios ‡πÉ‡∏ô‡πÄ‡∏Å‡∏° strategy
- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì conversion rates ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á resources

#### 5. **Rhythm & Music Games**
‡∏´‡∏≤‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞‡∏ó‡∏µ‡πà pattern ‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô
```
Example:
- Beat Pattern A: repeats every 12 beats
- Beat Pattern B: repeats every 8 beats
GCD(12, 8) = 4
Patterns sync every 4 beats
```
- ‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö rhythm patterns ‡∏ó‡∏µ‡πà‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô
- ‡∏õ‡∏£‡∏∞‡∏™‡∏≤‡∏ô multiple music tracks
- ‡∏™‡∏£‡πâ‡∏≤‡∏á procedural music ‡∏ó‡∏µ‡πà‡∏°‡∏µ pattern

#### 6. **Enemy Spawn & Wave System**
‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ spawn cycles ‡∏Ç‡∏≠‡∏á‡∏®‡∏±‡∏ï‡∏£‡∏π‡∏´‡∏•‡∏≤‡∏¢‡∏ä‡∏ô‡∏¥‡∏î
```
Example:
- Enemy Type A spawns every 30 seconds
- Enemy Type B spawns every 45 seconds
GCD(30, 45) = 15
Both types spawn together every 15 seconds initially,
then full cycle repeats every LCM(30,45) = 90 seconds
```
- ‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö wave patterns ‡∏ó‡∏µ‡πà‡∏™‡∏°‡∏î‡∏∏‡∏•
- ‡∏™‡∏£‡πâ‡∏≤‡∏á difficulty curves ‡∏ó‡∏µ‡πà‡∏ô‡πà‡∏≤‡∏™‡∏ô‡πÉ‡∏à
- ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° spawn rate ‡∏Ç‡∏≠‡∏á multiple enemy types

#### 7. **Stat System & Damage Calculation**
‡∏•‡∏î‡∏ó‡∏≠‡∏ô damage ratios
```
Example:
Physical Damage: 150
Magic Damage: 100
GCD(150, 100) = 50
Simplified Ratio = 3:2
```
- ‡πÅ‡∏™‡∏î‡∏á stat ratios ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏á‡πà‡∏≤‡∏¢
- ‡∏™‡∏£‡πâ‡∏≤‡∏á balanced character builds
- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì damage distribution

#### 8. **Procedural Generation**
‡∏™‡∏£‡πâ‡∏≤‡∏á repeating patterns
```
Example:
Generate terrain features:
- Trees every 12 tiles
- Rocks every 18 tiles
GCD(12, 18) = 6
Common spacing = 6 tiles (can use as base unit)
```
- ‡∏™‡∏£‡πâ‡∏≤‡∏á procedural world ‡∏ó‡∏µ‡πà‡∏°‡∏µ pattern
- ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ repeating elements
- ‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö dungeon layouts

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÇ‡∏Ñ‡πâ‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á:**
```csharp
// Example 1: Aspect Ratio Calculator
int screenWidth = 1920;
int screenHeight = 1080;
int gcd = GCD(screenWidth, screenHeight);
Debug.Log($"Aspect Ratio: {screenWidth/gcd}:{screenHeight/gcd}"); // 16:9

// Example 2: Grid Snap System
int objectSize = 48;
int gridSize = 32;
int snapUnit = GCD(objectSize, gridSize); // 16
// Object can snap to grid at multiples of 16 pixels

// Example 3: Crafting Recipe Simplification
int woodCost = 24;
int stoneCost = 18;
int simplifier = GCD(woodCost, stoneCost); // 6
Debug.Log($"Simplified Recipe: {woodCost/simplifier} Wood + {stoneCost/simplifier} Stone");
// Output: 4 Wood + 3 Stone
```

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÉ‡∏ô‡πÄ‡∏Å‡∏°:**
- **UI Design:** ‡∏õ‡∏£‡∏±‡∏ö resolution ‡πÅ‡∏•‡∏∞ aspect ratio ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
- **Animation System:** ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå multiple animation loops
- **Tile-based Games:** ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì grid alignment ‡∏ó‡∏µ‡πà‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡πÅ‡∏ö‡∏ö
- **Strategy Games:** ‡∏•‡∏î‡∏ó‡∏≠‡∏ô resource costs ‡πÉ‡∏´‡πâ‡∏≠‡πà‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢
- **Rhythm Games:** ‡∏´‡∏≤ beat synchronization points

**Method Signature:**
```csharp
void ASN03_RecursiveGCD(int a, int b)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
1. ‡∏™‡∏£‡πâ‡∏≤‡∏á helper method ‡πÅ‡∏ö‡∏ö recursive ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö parameters: a ‡πÅ‡∏•‡∏∞ b
2. Base Case: ‡∏ñ‡πâ‡∏≤ b == 0 ‡πÉ‡∏´‡πâ return a
3. Recursive Case: return GCD(b, a % b)
4. ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç

**‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:** Algorithm ‡∏ô‡∏µ‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏£‡∏ß‡∏î‡πÄ‡∏£‡πá‡∏ß‡∏°‡∏≤‡∏Å (Time Complexity: O(log(min(a,b))))

**Test Cases:**
1. **Input:** a = 48, b = 18
   **Expected Output:**
   ```
   6
   ```

2. **Input:** a = 100, b = 75
   **Expected Output:**
   ```
   25
   ```

3. **Input:** a = 7, b = 3
   **Expected Output:**
   ```
   1
   ```

4. **Input:** a = 54, b = 24
   **Expected Output:**
   ```
   6
   ```

5. **Input:** a = 17, b = 13
   **Expected Output:**
   ```
   1
   ```

6. **Input:** a = 25, b = 15
   **Expected Output:**
   ```
   5
   ```

### ASN04_RecursiveBinarySearch

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:** ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ Target ‡πÉ‡∏ô Array ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏î‡πâ‡∏ß‡∏¢ Binary Search ‡πÅ‡∏ö‡∏ö Recursion

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏õ‡∏±‡∏ç‡∏´‡∏≤:**
Binary Search ‡πÄ‡∏õ‡πá‡∏ô algorithm ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÅ‡∏•‡πâ‡∏ß ‡πÇ‡∏î‡∏¢‡πÅ‡∏ö‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏£‡∏∂‡πà‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏≠‡∏ö

‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô:
1. ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á (mid) ‡∏Ç‡∏≠‡∏á array
2. ‡∏ñ‡πâ‡∏≤‡∏Ñ‡πà‡∏≤‡∏Å‡∏•‡∏≤‡∏á‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö target ‡∏Å‡πá‡∏û‡∏ö‡πÅ‡∏•‡πâ‡∏ß
3. ‡∏ñ‡πâ‡∏≤ target ‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤‡∏Ñ‡πà‡∏≤‡∏Å‡∏•‡∏≤‡∏á ‡πÉ‡∏´‡πâ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ñ‡∏£‡∏∂‡πà‡∏á‡∏ã‡πâ‡∏≤‡∏¢
4. ‡∏ñ‡πâ‡∏≤ target ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡∏Ñ‡πà‡∏≤‡∏Å‡∏•‡∏≤‡∏á ‡πÉ‡∏´‡πâ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ñ‡∏£‡∏∂‡πà‡∏á‡∏Ç‡∏ß‡∏≤
5. ‡∏ó‡∏≥‡∏ã‡πâ‡∏≥‡∏à‡∏ô‡∏û‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡∏´‡∏°‡∏î range

‡πÉ‡∏ô‡πÄ‡∏Å‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£:
- ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏ô leaderboard ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö
- ‡∏´‡∏≤‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°‡πÉ‡∏ô inventory ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° ID ‡∏´‡∏£‡∏∑‡∏≠ name
- ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ NPC ‡∏´‡∏£‡∏∑‡∏≠ object ‡∏ó‡∏µ‡πà‡∏°‡∏µ ID ‡πÄ‡∏â‡∏û‡∏≤‡∏∞
- ‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô database ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£ index ‡πÅ‡∏•‡πâ‡∏ß

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÉ‡∏ô‡πÄ‡∏Å‡∏°:**
- ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ player rank ‡πÉ‡∏ô sorted leaderboard
- ‡∏´‡∏≤ skill ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏à‡∏≤‡∏Å sorted skill list
- ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ quest ‡∏ó‡∏µ‡πà‡∏°‡∏µ ID ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö

**Method Signature:**
```csharp
void ASN04_RecursiveBinarySearch(int[] arr, int target)
```

**Logic ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á implement:**
1. ‡∏™‡∏£‡πâ‡∏≤‡∏á helper method ‡πÅ‡∏ö‡∏ö recursive ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö parameters: array, target, low, high
2. Base Case: ‡∏ñ‡πâ‡∏≤ low > high ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö return -1
3. ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì mid = low + (high - low) / 2
4. ‡∏ñ‡πâ‡∏≤ arr[mid] == target return mid
5. ‡∏ñ‡πâ‡∏≤ arr[mid] > target ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ñ‡∏£‡∏∂‡πà‡∏á‡∏ã‡πâ‡∏≤‡∏¢: return BinarySearch(arr, target, low, mid-1)
6. ‡∏ñ‡πâ‡∏≤ arr[mid] < target ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ñ‡∏£‡∏∂‡πà‡∏á‡∏Ç‡∏ß‡∏≤: return BinarySearch(arr, target, mid+1, high)
7. ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• index ‡∏ó‡∏µ‡πà‡∏û‡∏ö ‡∏´‡∏£‡∏∑‡∏≠ -1 ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö

**‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:** 
- Array ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏à‡∏≤‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÑ‡∏õ‡∏°‡∏≤‡∏Å‡∏Å‡πà‡∏≠‡∏ô
- Time Complexity: O(log n) ‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤ Sequential Search ‡∏°‡∏≤‡∏Å
- ‡πÅ‡∏ï‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô

**Test Cases:**
1. **Input:** arr = [1, 3, 5, 7, 9], target = 5
   **Expected Output:**
   ```
   2
   ```

2. **Input:** arr = [1, 2, 3, 4, 5], target = 6
   **Expected Output:**
   ```
   -1
   ```

3. **Input:** arr = [10], target = 10
   **Expected Output:**
   ```
   0
   ```

4. **Input:** arr = [1, 2, 3], target = 0
   **Expected Output:**
   ```
   -1
   ```

5. **Input:** arr = [2, 4, 6, 8, 10], target = 4
   **Expected Output:**
   ```
   1
   ```

6. **Input:** arr = [1, 3, 5], target = 1
   **Expected Output:**
   ```
   0
   ```

7. **Input:** arr = [1, 2, 3, 4], target = 5
   **Expected Output:**
   ```
   -1
   ```

8. **Input:** arr = [5], target = 6
   **Expected Output:**
   ```
   -1
   ```

---

## üí° ‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°

### 1. ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Stack Overflow
- Recursion ‡πÉ‡∏ä‡πâ Stack Memory
- ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö input ‡πÉ‡∏´‡∏ç‡πà ‡∏≠‡∏≤‡∏à‡πÄ‡∏Å‡∏¥‡∏î Stack Overflow
- ‡∏û‡∏¥‡∏à‡∏≤‡∏£‡∏ì‡∏≤‡πÉ‡∏ä‡πâ Iterative ‡πÅ‡∏ó‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÉ‡∏´‡∏ç‡πà

### 2. ‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ Recursion
- **‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏ó‡∏µ‡πà‡πÅ‡∏ö‡πà‡∏á‡πÑ‡∏î‡πâ**: Factorial, Fibonacci
- **‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏ó‡∏µ‡πà‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô**: Binary Search, GCD
- **‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á**: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö loop ‡∏ò‡∏£‡∏£‡∏°‡∏î‡∏≤

### 3. ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Edge Cases
- **Input ‡πÄ‡∏õ‡πá‡∏ô 0 ‡∏´‡∏£‡∏∑‡∏≠ 1**: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Base Case
- **Array ‡∏ß‡πà‡∏≤‡∏á**: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö length
- **String ‡∏ß‡πà‡∏≤‡∏á**: ‡πÄ‡∏õ‡πá‡∏ô Palindrome

---

## üöÄ ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡πÄ‡∏Å‡∏°

### 1. RPG Game
- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì damage ‡∏´‡∏£‡∏∑‡∏≠ stat ‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡πÅ‡∏ö‡∏ö exponential
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏´‡∏±‡∏™‡∏´‡∏£‡∏∑‡∏≠‡∏ä‡∏∑‡πà‡∏≠‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô Palindrome
- ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÉ‡∏ô leaderboard ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö

### 2. Strategy Game
- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≠‡∏á‡∏ó‡∏±‡∏û (Factorial)
- ‡∏´‡∏≤ GCD ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏•‡∏î‡∏ó‡∏≠‡∏ô resource
- ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÉ‡∏ô map ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö

### 3. Puzzle Game
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö pattern ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô Palindrome
- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Fibonacci ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏¥‡∏ö‡πÇ‡∏ï‡∏Ç‡∏≠‡∏á puzzle pieces
- Binary Search ‡πÉ‡∏ô sequence ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö